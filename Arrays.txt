		ARRAYS QUESTIONS (TARGET 6 DAYS)

Q1  Reverse a String(DEALS WITH STRING AND ARRAY)
(Naive approach)

	String rev = "";
        for(int i = str.length()-1; i>=0; i--){
            rev+=str.charAt(i);
        }
        return rev;

(Approach 1)
Using Built-in methods of StringBuilder (append and reverse)

	StringBuilder str1 = new StringBuilder();
        str1.append(str);
        str1.reverse();
        return str1.toString();

(Approach 2)
public static String reverseWord(String str)
    {
        // Reverse the string str
        char arr[] = str.toCharArray();
        int start = 0;
        int end = arr.length-1;
        while(start<end){
            char temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
        return new String(arr);
    }

(Approach 3)
Reverse using stack

String rev = "";
        int n = S.length();
        Stack<Character> st = new Stack<>();
        for(int i = 0;i<n; i++){
            st.push(S.charAt(i));
        }
        while(!st.isEmpty()){
            rev+= st.pop();
        }
        return rev;



Q2  Find minimum and maximum element in an array

https://practice.geeksforgeeks.org/problems/find-minimum-and-maximum-element-in-an-array4428/1#

https://www.youtube.com/watch?v=txd3UKiSD5Q
(Approach 1)
when pair class was given to us in the code..

1.Initialize first element as max, min
2. Now compare with every element
Time Complexity = O(n)
No of comparisions : a) Best case: n-1 (Descending order)
		     b) Worst case : 2(n-1)  (Ascending order)
             
static pair getMinMax(long a[], long n)  
    {
        
        pair p = new pair(a[0],a[0]);
        for(int i = 1; i<n; i++){
            if(a[i]>p.second){
                p.second = a[i];
            }else if(a[i]<p.first){
                p.first = a[i];
            }
        }
        return p;
    }

(Appproach 2) 
Comparing in pairs
1. n = odd -> min = max = a[0]
   n = evn -> min= a[0] , max = a[1]
		check if a[0]>a[1] if so then max = a[0] & min = a[1]
		      if a[0]<a[1] if so then max = a[1] & min = a[0]
2.then compare in pairs 
		if a[i] > a[i+1] then max among both is a[i] which is then compared to the max
				 & min among both is a[i+1] which is then compared to min
		if a[i] < a[i+1] then min is a[i] which is comp to min
				 & max is a[i+1] , comp to max.
Time complexity : O(n)
No of comparisions: 2 elements -> 3 comparsion
		    for n elements -> 3n/2 comparisions
			odd -> 3(n-1)/2
			even -> 3(n-2)/2  + 1 (for a[0] & a[1] comp)
				= 3n-4/2 = 3n/2 -2


	int i;
        pair p;
        if(n%2==0){
            if(a[0]>a[1]){
                p = new pair(a[1],a[0]);
            }else{
                p = new pair(a[0],a[1]);
            }
            i = 2;
        }else{
            p = new pair(a[0],a[0]);
            i=1;
        }
        while(i<n-1){
            if(a[i]>a[i+1]){
                if(a[i]>p.second){
                    p.second = a[i];
                }
                if(a[i+1]<p.first){
                    p.first = a[i+1];
                }
            }else{
                if(a[i+1]>p.second){
                    p.second = a[i+1];
                }
                if(a[i]<p.first){
                    p.first = a[i];
                }
            }
            i = i+2;
        }
        return p;

Q3 Find the Kth max and min element of an array

(Naive Approach)
	Arrays.sort(arr);
        return arr[k-1];
Time complexity = O(nlogn) ( Sorting -> Merge,heap)

(Approach 2)
(Heap)

(Approach 3)
(Quick Select)



Q4 Sort an array of 0,1 and 2 (Without using any sorting algo)

(Approach 1)
Count sort
1.count zeroes, ones and twos
2. then place that many no.of 0's , 1's and 2's in the array
(No need to take extra array)
0-> cnt_zeroes
cnt_zeroes -> cnt_zeroes + cnt_ones
cnt_zeroes + cnt_ones -> n

	int cnt_zeroes = 0;
        int cnt_ones = 0;
        int cnt_twos = 0;
        
        for(int i = 0; i<n; i++){
            if(a[i]==0){
                cnt_zeroes+=1;
            }
            if(a[i]==1){
                cnt_ones +=1;
            }
            if(a[i]==2){
                cnt_twos +=1;
            }
        }
        for(int i = 0; i<cnt_zeroes; i++){
            a[i] = 0;
        }
        for(int i = cnt_zeroes; i< cnt_zeroes+cnt_ones; i++){
            a[i] = 1;
        }
        for(int i = cnt_zeroes+cnt_ones; i<n; i++){
            a[i] = 2;
        }

(Approach 2)
Dutch National Flag Algo

a[0,..low-1] = 0
a[high,... n] = 2
a[low....mid-1] = 1

if a[mid] = 0 then swap a[low], a[mid]
		    low++, mid++
if a[mid] = 1 then mid++
if a[mid] = 2 then swap a[mid], a[high]
		       high--


	int lo = 0;
        int hi = a.length - 1;
        int mid = 0, temp = 0;
        while (mid <= hi){
            if(a[mid] == 0){
                temp = a[lo];
                a[lo] = a[mid];
                a[mid] = temp;
                lo++;
                mid++;
            }
            else if(a[mid]==1){
                mid++;
            }
            else if(a[mid] == 2){
                temp = a[mid];
                a[mid] = a[hi];
                a[hi] = temp;
                hi--;
            }
        }



Q5 Move all the negative elements to one side of the array

https://practice.geeksforgeeks.org/problems/move-all-negative-elements-to-end1813/1

https://leetcode.com/problems/sort-array-by-parity/

Ask 2 ques to interviewer:
1. Extra space allowed ?
2. Order of elements is to be maintained ?

2 variations in Q
a
input : -2, 3,-1, 8, -3, 6, -5, 9
output : -2, -1, -3, -5, 3, 8, 6, 9
b
input : -2, 3,-1, 8, -3, 6, -5, 9
output : 3, 8, 6, 9, -2, -1, -3, -5

Naive Approach 
(solving b variation)

1. Take an array 
2. Run a loop & copy all positive elements in it 
3. then copy all the negative elements inside it.
(In this approach order of + and - elements is maintained)

	int temp[] = new int[n];
        int j = 0;
        for(int i = 0; i<n; i++){
            if(arr[i]>=0){
                temp[j] = arr[i];
                j++;
            }
        }
        // if(j==n||j==0){
        //     return;
        // }
        for(int i = 0; i<n; i++){
            if(arr[i]<0){
                temp[j] = arr[i];
                j++;
            }
        }
        for(int i = 0; i<n; i++){
            arr[i] = temp[i];
        }
 

(When order is not to be maintained)
Two pointer approach

left right
 -     -    --> right--
 +     -    --> left++, right--
 +     +    --> left++
 -     +    --> swap(arr[left], arr[right]), left++, right--

Time complexity : o(n)
Space complexity: o(1)

	int left = 0;
        int right = arr.length-1;
        while(left<=right){
            if(arr[left]<0 &&arr[right]<0){
                right--;
            }
            else if(arr[left]>0 && arr[right]<0){
                left++;
                right--;
            }
            else if(arr[left]>0 && arr[right]>0){
                left++;
            }
            else{
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right]= temp;
                left++;
                right--;
            }
        }


(Approach 3)
1 -1 3 2 -7 -5 11 6
your output is: 
1 3 2 11 6 -5 -1 -7 
(Order of negative elements is not maintained)

	int j = 0; // to track - elements 
        for(int i = 0; i<n; i++){
            if(arr[i]>0){
                if(i!=j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                j++;
            }
        }


Q6 Union and Intersesction of two sorted arrays

https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/


UNION
(Approach 1)
Use HashSet

1.Take a empty set
2. loop through first array and place its elements inside the Set
3. Loop through second array and place its elemenst inside Set
(Set contains a single element only once --> task done automatically)

	Set<Integer> finalUnion = new HashSet<>();
        int i = 0;
        int j = 0;
        while(i<a.length){
            finalUnion.add(a[i]);
            i++;
        }
        while(j<b.length){
            finalUnion.add(b[j]);
            j++;
        }
        return finalUnion.size();
    

INTERSECTION 
(Approach 1)
Use HashSet

	HashSet<Integer> hs = new HashSet<>();
        HashSet<Integer> hs1 = new HashSet<>();
        int count = 0;
        for(int i = 0; i<n; i++){
            hs.add(a[i]);
        }
        for(int i = 0; i<m; i++){
            hs1.add(b[i]);
        }
        for(int set: hs1){
            if(hs.contains(set)){
                count++;
            }
            
        }
        return count;    


Q7 Cylically rotate an array by one

https://practice.geeksforgeeks.org/problems/cyclically-rotate-an-array-by-one2614/1#
https://practice.geeksforgeeks.org/problems/rotate-array-by-n-elements/0
https://leetcode.com/problems/rotate-array/

input : 1 2 3 4 5
output: 5 1 2 3 4
(Naive aproach)
Time complexity = O(n)
	
	long last = arr[arr.length-1];
        for(int i = arr.length-1; i>0; i--){
            arr[i] = arr[i-1];
        }
        arr[0] = last;


FOR VARIATION IN Q
input : 1 2 3 4 5
output: 3 4 5 1 2

(Approach 1)
(SOLN BELOW GIVNG TLE)
Time complexity: O(n*d)

for(int i = 0; i<D; i++){
	rotateLeft(arr, N, D);
}
public static void rotateLeft(int arr[], int N , int D){
	   int temp = arr[0];
	   for(int i = 0; i<N-1; i++){
	       arr[i] = arr[i+1];
	   }
	   arr[N-1] = temp;
}

(Approach 2)
1. Take out first d eements  abd store inside temp array
2. Left shift the array elements
3. Store the temp array elemets back to the original array(after left shift of its elements)

Time complexity: O(n)
Space complexity : O(d)

	    int temp[] = new int[D];
	    for(int i = 0; i<D; i++){
	        temp[i] = arr[i];
	    }
	    for(int i = D; i<N; i++){
	        arr[i-D] = arr[i];
	    }    
	   // for(int i = N-D; i<N; i++){
	   //     for(int j = 0; j<temp.length; j++){
	   //         arr[i] = temp[j];
	   //     }
	   // }
	   int i = N-D;
	   int j = 0;
	   while(i<N && j<D){
	       arr[i] = temp[j];
	       i++;
	       j++;
	   }





