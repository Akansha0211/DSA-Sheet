		Hashmap (6 June)

Q1. subarray with a given target k
https://leetcode.com/problems/subarray-sum-equals-k/

Brute Force

public int subarraySum(int[] nums, int k) {
        int count = 0;
        for(int i = 0; i<nums.length; i++){
            int sum = 0;
            for(int j = i; j<nums.length; j++){
                sum+=nums[j];
                if(sum == k){
                    count++;
                }
            }
        }
        return count;
    }

(Approach 2)
public int subarraySum(int[] nums, int k) {
        int psa[] = new int[nums.length];
        psa[0] = nums[0];
        for(int i = 1; i<nums.length; i++){       
            psa[i] = psa[i-1] + nums[i];
        }
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,1);
        int count = 0;
        for(int i = 0; i<psa.length; i++){
            if(hm.containsKey(psa[i]-k)){
                count+=hm.get(psa[i]-k);
            }
            if(hm.containsKey(psa[i])){
                hm.put(psa[i],hm.get(psa[i])+1);
            }else{
                hm.put(psa[i],1);
            }
        }
        return count;
    }


Q2 subarray div by k.
https://leetcode.com/problems/subarray-sums-divisible-by-k/

(Approach 1)

public int subarraysDivByK(int[] nums, int k) {
        int psa[] = new int[nums.length];
        int psam[] = new int[nums.length];
        psa[0] = nums[0];
        for(int i = 1; i<psa.length; i++){
            psa[i] = psa[i-1]+nums[i];
        }
        for(int i = 0; i<psam.length; i++){
            psam[i] = psa[i] % k;
            if(psa[i]%k<0){
                psam[i] = (psa[i]%k)+k;
            }
            
        }
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,1);
        int count = 0;
        for(int i = 0; i<psam.length; i++){
            if(hm.containsKey(psam[i])){
                count+=hm.get(psam[i]);
            }
            if(hm.containsKey(psam[i])){
                hm.put(psam[i],hm.get(psam[i])+1);
            }else{
                hm.put(psam[i],1);
            }
        }
        return count;
    }

Q3  same difference


Q4 subarrays with equal 1's and 0's
https://practice.geeksforgeeks.org/problems/count-subarrays-with-equal-number-of-1s-and-0s-1587115620/1#

(Approach 1)

(Approach 2)
static int countSubarrWithEqualZeroAndOne(int arr[], int n)
    {
        // add your code here
        int pc0[] = new int[arr.length];
        int pc1[] = new int[arr.length];
        if(arr[0]==0){
            pc0[0] = 1;
            pc1[0] = 0;
        }
        if(arr[0] ==1){
            pc0[0] = 0;
            pc1[0] = 1;
        }
        for(int i = 1; i<arr.length; i++){
            if(arr[i]!=0){
                pc0[i] = pc0[i-1];
                pc1[i] = pc1[i-1]+1;
            }else{
                pc0[i] = pc0[i-1]+1;
                pc1[i] = pc1[i-1];
            }
        }
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,1);
        int count = 0;
        for(int i = 0; i<arr.length; i++){
            if(hm.containsKey(pc0[i]-pc1[i])){
                count+=hm.get(pc0[i]-pc1[i]);
                hm.put(pc0[i]-pc1[i],hm.get(pc0[i]-pc1[i])+1);
            }else{
                hm.put(pc0[i]-pc1[i],1);
            }
        }
        return count;
    }


Q5 Substring with equal 0,1 and 2
https://practice.geeksforgeeks.org/problems/equal-0-1-and-23208/1#


long getSubstringWithEqual012(String str) 
    { 
        // code here
        int pc0 = 0;
        int pc1 = 0;
        int pc2 = 0;
        String key = Integer.toString(pc0-pc1)+ "#" + Integer.toString(pc0-pc2);
        HashMap<String,Integer> hm = new HashMap<>();
        hm.put(key,1);
        long count = 0;
        for(int i = 0; i<str.length(); i++){
            if(str.charAt(i)=='0'){
                pc0++;
            }
            else if(str.charAt(i)=='1'){
                pc1++;
            }
            else{
                pc2++;
            }
            key = Integer.toString(pc0-pc1) + '#' + Integer.toString(pc0-pc2);
            if(hm.containsKey(key)){
                count+=hm.get(key);
                hm.put(key,hm.get(key)+1);
            }else{
                hm.put(key,1);
            }
        }
        return count;
    }

Q6 K closest point from origin 
https://leetcode.com/problems/k-closest-points-to-origin/

(Approach 1)

 public static class Pair implements Comparable<Pair>{
        int index;
        int distance;
        
        Pair(){
            
        }
        Pair(int index, int distance){
            this.index = index;
            this.distance = distance;
            
        }
        public int compareTo(Pair o){
            return this.distance - o.distance;
        }
    }
    public int[][] kClosest(int[][] points, int k) {
        int[][] ans = new int[k][points[0].length];
        PriorityQueue<Pair>pq = new PriorityQueue<>(Collections.reverseOrder());
        for(int i = 0; i<points.length; i++){
            int x = points[i][0];
            int y = points[i][1];
            int dist = y*y +x*x;
            if(pq.size()<k){
                pq.add(new Pair(i,dist));
            }else{
                if(pq.peek().distance>dist){
                    pq.remove();
                    pq.add(new Pair(i,dist));
                }
            }
        }
        while(pq.size()>0){            
            for(int i = 0; i<ans.length; i++){
                Pair rem = pq.remove();
                int index = rem.index;
                ans[i] = points[index];
            }
                    
        }

	//int i = 0;
        // while(pq.size()>0){            
        //      Pair rem = pq.remove();
        //      int index = rem.index;
        //      ans[i] = points[index]; 
        //     i++;
        // }

        return ans;
    }


Q7. Longest consecutive 1's.
https://leetcode.com/problems/max-consecutive-ones/

public int findMaxConsecutiveOnes(int[] nums) {
        int curr_count = 0;
        int max_count = 0;
        for(int i = 0; i<nums.length; i++){
            if(nums[i] == 0){
                curr_count = 0;
            }else{
                curr_count = curr_count+1;
                max_count = Math.max(curr_count,max_count);
            }
        }
        return max_count;
    }


		HashMap(12 June)

Q8 Rabbits in forest
https://leetcode.com/problems/rabbits-in-forest/

(Approach 1)

 public int numRabbits(int[] answers) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int ans = 0;
        for(int val : answers){
            hm.put(val, hm.getOrDefault(val,0)+1);
        }
        for(Integer n : hm.keySet()){
            int group = hm.get(n)/(n+1);
            if(hm.get(n)%(n+1)!=0){
                group = group+1;
            }
            ans+=group*(n+1);
            
        }
        return ans;
        
    }

Q9 Array of doubled Pair
https://leetcode.com/problems/array-of-doubled-pairs/

(Approach 1)

 public boolean canReorderDoubled(int[] arr) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        for(int val : arr){
            hm.put(val,hm.getOrDefault(val,0)+1);
        }
        Arrays.sort(arr);
        for(int val : arr){
            if(hm.get(val)>0){             
                if(val<0 && val%2==0){
                    if(hm.getOrDefault(val/2,0)>=1){
                        hm.put(val,hm.get(val)-1);
                        hm.put(val/2,hm.get(val/2)-1);
                    }else{
                        return false;
                    }
                    
                }else{
                    if(hm.getOrDefault(val*2,0)>=1){
                        hm.put(val,hm.get(val)-1);
                        hm.put(val*2,hm.get(val*2)-1);
                    }else{
                        return false;
                    }
                }
            }
        }
        return true;
    }


Q10. Longest consecutive sequence
https://leetcode.com/problems/longest-consecutive-sequence/

(Approach 1)

 public int longestConsecutive(int[] nums) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int ans = 0;
        for(int num : nums){
            if(!hm.containsKey(num)){
                int sp = num;
                int ep = num;
                if(hm.containsKey(num-1)==true){
                    sp = num - hm.get(num-1);
                }
                if(hm.containsKey(num+1)==true){
                    ep = num + hm.get(num+1);
                }
                int len = ep - sp +1;
                hm.put(sp,len);
                hm.put(ep,len);
                
                if(sp!=num && ep!=num){
                    hm.put(num,len);
                }
                ans = Math.max(ans,len);
            }
        }
        return ans;
    }   

Q11. Tricky sorting cost
https://practice.geeksforgeeks.org/problems/morning-assembly3038/1

(Approach 1)

static int sortingCost(int N, int arr[]){
        // code here
        int res = 0;
        int ans = 0;
        HashMap<Integer,Integer> hm = new HashMap<>();
        for(int val : arr){
            
            if(hm.containsKey(val-1)!=true){
                hm.put(val,1);
            }else{
                hm.put(val, hm.get(val-1)+1);
            }
            ans = Math.max(ans, hm.get(val));
            res = N - ans;
        }
        return res;
    }

Q12. Brick wall
https://leetcode.com/problems/brick-wall/

(Approach 1)

public int leastBricks(List<List<Integer>> wall) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int ans = 0;
        for(List<Integer> row: wall){
            int sum = 0;
            for(int i = 0; i<row.size()-1; i++){
                sum+=row.get(i);
                hm.put(sum, hm.getOrDefault(sum,0)+1);
                ans = Math.max(ans, hm.get(sum));
            }
        }
        return wall.size()-ans;
    }

Q13. Design HashMap
https://leetcode.com/problems/design-hashmap/

(Approach 1)

class MyHashMap {

    /** Initialize your data structure here. */
    private class Node{
        int key;
        int value;
        
        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }
    
    private int size;
    private LinkedList<Node> buckets[];
    public MyHashMap() {
        initbuckets(4);
        size = 0;
    }
    public void initbuckets(int N){
        buckets = new LinkedList[N];
        for(int i = 0; i<buckets.length; i++){
            buckets[i] = new LinkedList<>();
        }
    }
    
    /** value will always be non-negative. */
    public void put(int key, int value) {
        int bi = hashFn(key);
        int di = getIndexWithinBucket(key,bi);
        if(di!=-1){
            Node node = buckets[bi].get(di);
            node.value = value;
        }else{
            Node node = new Node(key, value);
            buckets[bi].add(node);
            size++;
        }
        double lambda = size * 1.0 /buckets.length;
        if(lambda>2.0){
            rehash();
        }
    }
    private void rehash(){
        LinkedList<Node> old[] = buckets;
        initbuckets(old.length *2);       
        size = 0;
        for(int i = 0; i<old.length;i++){
            for(Node node : old[i]){
                put(node.key,node.value);
            }
        }
    }
    private int hashFn(int key){
        // int hc =key.hashCode();
        // return Math.abs(hc) % buckets.length;
        return Math.abs(Integer.hashCode(key)) % buckets.length;
    }
    private int getIndexWithinBucket(int key, int bi){
        int di = 0;
        for(Node node : buckets[bi]){
            if(node.key == key){
                return di;
            }
            di++;
        }
        return -1;
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    public int get(int key) {
        int bi = hashFn(key);
        int di = getIndexWithinBucket(key,bi);
        if(di!=-1){
            Node node = buckets[bi].get(di);
            return node.value;
        }
        return -1;
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    public void remove(int key) {
        int bi = hashFn(key);
        int di = getIndexWithinBucket(key,bi);
        if(di!=-1){
            Node node = buckets[bi].remove(di);
            size--;
            // return node.value;
        }
        // return -1;
    }
}


Q14. Isomorphic Strings
https://leetcode.com/problems/isomorphic-strings/

(Approach 1)

public boolean isIsomorphic(String s, String t) {
        if(s.length() != t.length()){
            return false;
        }
        HashMap<Character, Character> map1 = new HashMap<>();
        HashMap<Character,Boolean> map2 = new HashMap<>();
        for(int i = 0; i< s.length(); i++){
            char ch1 = s.charAt(i);
            char ch2 = t.charAt(i);
            if(map1.containsKey(ch1)==true){
                if(map1.get(ch1) != ch2){
                    return false;
                }
                
            }else{
                if(map2.containsKey(ch2)==true){
                    return false;
                }else{
                    map1.put(ch1,ch2);
                    map2.put(ch2,true);
                }
            }
        }
        return true;
    }

(Approach 2)

public boolean isIsomorphic(String s, String t) {
        if(s.length()!= t.length()){
            return true;
        }
        HashMap<Character,Character> map1 = new HashMap<>();
        HashMap<Character,Character> map2 = new HashMap<>();
        for(int i = 0; i<s.length();i++){
            char ch1 = s.charAt(i);
            char ch2 = t.charAt(i);
            if(map1.containsKey(ch1)==true){
                if(map1.get(ch1)!=ch2){
                    return false;
                }
            }else{
                if(map2.containsKey(ch2)==true){
                    if(map2.get(ch2)!=ch1){
                        return false;
                    }
                }else{
                    map1.put(ch1,ch2);
                    map2.put(ch2,ch1);
                }
            }
        }
        return true;
    }

Q15. Island Perimeter
https://leetcode.com/problems/island-perimeter/

(Approach 1)

public int islandPerimeter(int[][] grid) {
        int peri = 0;
        for(int i = 0; i<grid.length; i++){
            for(int j = 0; j<grid[i].length; j++){
                if(grid[i][j]==1){
                    if(i==0 || grid[i-1][j]==0)peri++;
                    if(j==0 || grid[i][j-1]==0)peri++;
                    if(i+1 == grid.length || grid[i+1][j]==0)peri++;
                    if(j+1 == grid[0].length || grid[i][j+1]==0)peri++;
                }
            }
        }
        return peri;
    }

(Approach 2)

public int islandPerimeter(int[][] grid) {
        
        int islands = 0;
        int neighbours = 0;
        for(int i = 0; i<grid.length; i++){
            for(int j = 0; j<grid[i].length; j++){
                if(grid[i][j]==1){
                    islands++;
                    if(j<grid[i].length-1 && grid[i][j+1] == 1){
                        neighbours++;
                    }
                    if(i<grid.length-1 && grid[i+1][j]==1){
                        neighbours++;
                    }
                }
            }
        }
        return 4*islands - 2*neighbours;
    }

Q16. Bulb Switcher
https://leetcode.com/problems/bulb-switcher/

(Approach 1)

 public int bulbSwitch(int n) {
        int i = 1;
        int count = 0;
        while(i*i<=n){
            i++;
            count++;
        }
        return count;
    }

		17th June 

Q17. Trapping Rain Water
https://leetcode.com/problems/trapping-rain-water/

(Approach 1)

public int trap(int[] height) {
        if(height.length == 0){
            return 0;
        }
        int left_max[] = new int[height.length];
        int right_max[] = new int[height.length];
        int ans = 0;
        left_max[0] = height[0];
        for(int i = 1; i<height.length; i++){
            if(height[i]>left_max[i-1]){
                left_max[i] = height[i];
            }else{
                left_max[i] = left_max[i-1];
            }
        }
        right_max[height.length -1] = height[height.length-1];
        for(int i = height.length-2; i>=0; i--){
            if(height[i]>right_max[i+1]){
                right_max[i] = height[i];
            }else{
                right_max[i] = right_max[i+1];
            }
        }
        for(int i = 1; i<height.length-1; i++){
            ans += Math.min(right_max[i], left_max[i])-height[i];
        }
        return ans;
    }

(Approach 2)optimized approach.

public int trap(int[] height) {
        int i = 0;
        int j = height.length-1;
        int lmax = 0;
        int rmax = 0;
        int ans = 0;
        while(i<j){
             if(height[i]<height[j]){
                 if(height[i]>lmax){
                     lmax = height[i];
                 }
                 ans+=lmax-height[i];
                 i++;
             }else{
                 if(height[j]>rmax){
                     rmax = height[j];
                 }
                 ans+=rmax - height[j];
                 j--;
             }
        }
        return ans;
    }

Q18. Trapping Rain Water 2
https://leetcode.com/problems/trapping-rain-water-ii/

public class Pair implements Comparable<Pair>{
            int row;
            int col;
            int val;
            public Pair(int row, int col, int val){
                this.row = row;
                this.col = col;
                this.val = val;
            }
        public int compareTo(Pair o){
            return this.val - o.val;
        }
    }
    public int trapRainWater(int[][] heightMap) {
        if(heightMap == null || heightMap.length <=2 || heightMap[0].length <=2){
            return 0;
        }
        PriorityQueue<Pair> queue = new PriorityQueue<>();
        int m = heightMap.length;
        int n = heightMap[0].length;
        boolean vis[][] = new boolean[m][n];
        for(int i = 0; i<m; i++){
            vis[i][0] = true;
            vis[i][n-1] = true;
            queue.add(new Pair(i,0,heightMap[i][0]));
            queue.add(new Pair(i,n-1,heightMap[i][n-1]));
        }
        for(int i = 1; i<n-1; i++){
            vis[0][i] = true;
            vis[m-1][i] = true;
            queue.add(new Pair(0,i,heightMap[0][i]));
            queue.add(new Pair(m-1,i, heightMap[m-1][i]));
        }
        int ans = 0;
        while(!queue.isEmpty()){
            Pair pair = queue.remove();
            int row = pair.row;
            int col = pair.col;
            
            if(row-1>=0 && !vis[row-1][col]){
                vis[row-1][col] = true;
                if(pair.val > heightMap[row-1][col]){
                    ans+= pair.val - heightMap[row-1][col];
                }
                queue.add(new Pair(row-1,col,Math.max(pair.val, heightMap[row-1][col])));
            }
            if(row+1<m && !vis[row+1][col]){
                vis[row+1][col] = true;
                if(pair.val > heightMap[row+1][col]){
                    ans+= pair.val - heightMap[row+1][col];
                }
                queue.add(new Pair(row+1,col, Math.max(pair.val,heightMap[row+1][col])));
            }
            if(col-1>=0 && !vis[row][col-1]){
                vis[row][col-1] = true;
                if(pair.val > heightMap[row][col-1]){
                    ans+= pair.val - heightMap[row][col-1];
                }
                queue.add(new Pair(row, col-1, Math.max(pair.val, heightMap[row][col-1])));
            }
            if(col+1<n && !vis[row][col+1]){
                vis[row][col+1] = true;
                if(pair.val>heightMap[row][col+1]){
                    ans+= pair.val - heightMap[row][col+1];
                }
                queue.add(new Pair(row, col+1, Math.max(pair.val, heightMap[row][col+1])));
            }
        }
        return ans;
    }
 
Q19. Count Pair whose sum is divisible by k.
https://practice.geeksforgeeks.org/problems/pairs-which-are-divisible-by-41920/1#

(Approach 1)

public static int count4Divisibiles(int arr[], int n ) 
    { 
        int ans = 0;
        int rem = 0;
        //frequency map
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int elem : arr){
            rem = elem % 4;
            // need to handle 0 case also
            if(rem ==0){
                if(map.containsKey(0)==true){
                    ans+=map.get(0);
                }
                
            }else{
                if(map.containsKey(4 -rem)==true){
                    ans +=map.get(4 - rem);
                }
            }
            map.put(rem, map.getOrDefault(rem,0)+1);
        }
        return ans;
    }

Q20. Length of largest subarray with continuous elements.

