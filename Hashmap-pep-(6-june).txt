		Hashmap (6 June)

Q1. subarray with a given target k
https://leetcode.com/problems/subarray-sum-equals-k/

Brute Force

public int subarraySum(int[] nums, int k) {
        int count = 0;
        for(int i = 0; i<nums.length; i++){
            int sum = 0;
            for(int j = i; j<nums.length; j++){
                sum+=nums[j];
                if(sum == k){
                    count++;
                }
            }
        }
        return count;
    }

(Approach 2)
public int subarraySum(int[] nums, int k) {
        int psa[] = new int[nums.length];
        psa[0] = nums[0];
        for(int i = 1; i<nums.length; i++){       
            psa[i] = psa[i-1] + nums[i];
        }
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,1);
        int count = 0;
        for(int i = 0; i<psa.length; i++){
            if(hm.containsKey(psa[i]-k)){
                count+=hm.get(psa[i]-k);
            }
            if(hm.containsKey(psa[i])){
                hm.put(psa[i],hm.get(psa[i])+1);
            }else{
                hm.put(psa[i],1);
            }
        }
        return count;
    }


Q2 subarray div by k.
https://leetcode.com/problems/subarray-sums-divisible-by-k/

(Approach 1)

public int subarraysDivByK(int[] nums, int k) {
        int psa[] = new int[nums.length];
        int psam[] = new int[nums.length];
        psa[0] = nums[0];
        for(int i = 1; i<psa.length; i++){
            psa[i] = psa[i-1]+nums[i];
        }
        for(int i = 0; i<psam.length; i++){
            psam[i] = psa[i] % k;
            if(psa[i]%k<0){
                psam[i] = (psa[i]%k)+k;
            }
            
        }
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,1);
        int count = 0;
        for(int i = 0; i<psam.length; i++){
            if(hm.containsKey(psam[i])){
                count+=hm.get(psam[i]);
            }
            if(hm.containsKey(psam[i])){
                hm.put(psam[i],hm.get(psam[i])+1);
            }else{
                hm.put(psam[i],1);
            }
        }
        return count;
    }

Q3  same difference


Q4 subarrays with equal 1's and 0's
https://practice.geeksforgeeks.org/problems/count-subarrays-with-equal-number-of-1s-and-0s-1587115620/1#

(Approach 1)

(Approach 2)
static int countSubarrWithEqualZeroAndOne(int arr[], int n)
    {
        // add your code here
        int pc0[] = new int[arr.length];
        int pc1[] = new int[arr.length];
        if(arr[0]==0){
            pc0[0] = 1;
            pc1[0] = 0;
        }
        if(arr[0] ==1){
            pc0[0] = 0;
            pc1[0] = 1;
        }
        for(int i = 1; i<arr.length; i++){
            if(arr[i]!=0){
                pc0[i] = pc0[i-1];
                pc1[i] = pc1[i-1]+1;
            }else{
                pc0[i] = pc0[i-1]+1;
                pc1[i] = pc1[i-1];
            }
        }
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,1);
        int count = 0;
        for(int i = 0; i<arr.length; i++){
            if(hm.containsKey(pc0[i]-pc1[i])){
                count+=hm.get(pc0[i]-pc1[i]);
                hm.put(pc0[i]-pc1[i],hm.get(pc0[i]-pc1[i])+1);
            }else{
                hm.put(pc0[i]-pc1[i],1);
            }
        }
        return count;
    }


Q5 Substring with equal 0,1 and 2
https://practice.geeksforgeeks.org/problems/equal-0-1-and-23208/1#


long getSubstringWithEqual012(String str) 
    { 
        // code here
        int pc0 = 0;
        int pc1 = 0;
        int pc2 = 0;
        String key = Integer.toString(pc0-pc1)+ "#" + Integer.toString(pc0-pc2);
        HashMap<String,Integer> hm = new HashMap<>();
        hm.put(key,1);
        long count = 0;
        for(int i = 0; i<str.length(); i++){
            if(str.charAt(i)=='0'){
                pc0++;
            }
            else if(str.charAt(i)=='1'){
                pc1++;
            }
            else{
                pc2++;
            }
            key = Integer.toString(pc0-pc1) + '#' + Integer.toString(pc0-pc2);
            if(hm.containsKey(key)){
                count+=hm.get(key);
                hm.put(key,hm.get(key)+1);
            }else{
                hm.put(key,1);
            }
        }
        return count;
    }

Q6 K closest point from origin 
https://leetcode.com/problems/k-closest-points-to-origin/

(Approach 1)

 public static class Pair implements Comparable<Pair>{
        int index;
        int distance;
        
        Pair(){
            
        }
        Pair(int index, int distance){
            this.index = index;
            this.distance = distance;
            
        }
        public int compareTo(Pair o){
            return this.distance - o.distance;
        }
    }
    public int[][] kClosest(int[][] points, int k) {
        int[][] ans = new int[k][points[0].length];
        PriorityQueue<Pair>pq = new PriorityQueue<>(Collections.reverseOrder());
        for(int i = 0; i<points.length; i++){
            int x = points[i][0];
            int y = points[i][1];
            int dist = y*y +x*x;
            if(pq.size()<k){
                pq.add(new Pair(i,dist));
            }else{
                if(pq.peek().distance>dist){
                    pq.remove();
                    pq.add(new Pair(i,dist));
                }
            }
        }
        while(pq.size()>0){            
            for(int i = 0; i<ans.length; i++){
                Pair rem = pq.remove();
                int index = rem.index;
                ans[i] = points[index];
            }
                    
        }

	//int i = 0;
        // while(pq.size()>0){            
        //      Pair rem = pq.remove();
        //      int index = rem.index;
        //      ans[i] = points[index]; 
        //     i++;
        // }

        return ans;
    }


Q7. Longest consecutive 1's.
https://leetcode.com/problems/max-consecutive-ones/

public int findMaxConsecutiveOnes(int[] nums) {
        int curr_count = 0;
        int max_count = 0;
        for(int i = 0; i<nums.length; i++){
            if(nums[i] == 0){
                curr_count = 0;
            }else{
                curr_count = curr_count+1;
                max_count = Math.max(curr_count,max_count);
            }
        }
        return max_count;
    }


		HashMap(12 June)

Q8 Rabbits in forest
https://leetcode.com/problems/rabbits-in-forest/

(Approach 1)

 public int numRabbits(int[] answers) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int ans = 0;
        for(int val : answers){
            hm.put(val, hm.getOrDefault(val,0)+1);
        }
        for(Integer n : hm.keySet()){
            int group = hm.get(n)/(n+1);
            if(hm.get(n)%(n+1)!=0){
                group = group+1;
            }
            ans+=group*(n+1);
            
        }
        return ans;
        
    }

Q9 Array of doubled Pair
https://leetcode.com/problems/array-of-doubled-pairs/

(Approach 1)

 public boolean canReorderDoubled(int[] arr) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        for(int val : arr){
            hm.put(val,hm.getOrDefault(val,0)+1);
        }
        Arrays.sort(arr);
        for(int val : arr){
            if(hm.get(val)>0){             
                if(val<0 && val%2==0){
                    if(hm.getOrDefault(val/2,0)>=1){
                        hm.put(val,hm.get(val)-1);
                        hm.put(val/2,hm.get(val/2)-1);
                    }else{
                        return false;
                    }
                    
                }else{
                    if(hm.getOrDefault(val*2,0)>=1){
                        hm.put(val,hm.get(val)-1);
                        hm.put(val*2,hm.get(val*2)-1);
                    }else{
                        return false;
                    }
                }
            }
        }
        return true;
    }


Q10. Longest consecutive sequence
https://leetcode.com/problems/longest-consecutive-sequence/

(Approach 1)

 public int longestConsecutive(int[] nums) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int ans = 0;
        for(int num : nums){
            if(!hm.containsKey(num)){
                int sp = num;
                int ep = num;
                if(hm.containsKey(num-1)==true){
                    sp = num - hm.get(num-1);
                }
                if(hm.containsKey(num+1)==true){
                    ep = num + hm.get(num+1);
                }
                int len = ep - sp +1;
                hm.put(sp,len);
                hm.put(ep,len);
                
                if(sp!=num && ep!=num){
                    hm.put(num,len);
                }
                ans = Math.max(ans,len);
            }
        }
        return ans;
    }   

Q11. Tricky sorting cost
https://practice.geeksforgeeks.org/problems/morning-assembly3038/1

(Approach 1)

static int sortingCost(int N, int arr[]){
        // code here
        int res = 0;
        int ans = 0;
        HashMap<Integer,Integer> hm = new HashMap<>();
        for(int val : arr){
            
            if(hm.containsKey(val-1)!=true){
                hm.put(val,1);
            }else{
                hm.put(val, hm.get(val-1)+1);
            }
            ans = Math.max(ans, hm.get(val));
            res = N - ans;
        }
        return res;
    }

Q12. Brick wall
https://leetcode.com/problems/brick-wall/

(Approach 1)

public int leastBricks(List<List<Integer>> wall) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int ans = 0;
        for(List<Integer> row: wall){
            int sum = 0;
            for(int i = 0; i<row.size()-1; i++){
                sum+=row.get(i);
                hm.put(sum, hm.getOrDefault(sum,0)+1);
                ans = Math.max(ans, hm.get(sum));
            }
        }
        return wall.size()-ans;
    }

Q13. Design HashMap
https://leetcode.com/problems/design-hashmap/

(Approach 1)

class MyHashMap {

    /** Initialize your data structure here. */
    private class Node{
        int key;
        int value;
        
        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }
    
    private int size;
    private LinkedList<Node> buckets[];
    public MyHashMap() {
        buckets = new LinkedList[10000];
        for(int i = 0; i<buckets.length; i++){
            buckets[i] = new LinkedList<>();
        }
        size = 0;
    }
    
    /** value will always be non-negative. */
    public void put(int key, int value) {
        int bi = hashFn(key);
        int di = getIndexWithinBucket(key,bi);
        if(di!=-1){
            Node node = buckets[bi].get(di);
            node.value = value;
        }else{
            Node node = new Node(key, value);
            buckets[bi].add(node);
            size++;
        }
    }
    private int hashFn(int key){
        // int hc =key.hashCode();
        // return Math.abs(hc) % buckets.length;
        return Math.abs(Integer.hashCode(key)) % buckets.length;
    }
    private int getIndexWithinBucket(int key, int bi){
        int di = 0;
        for(Node node : buckets[bi]){
            if(node.key == key){
                return di;
            }
            di++;
        }
        return -1;
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    public int get(int key) {
        int bi = hashFn(key);
        int di = getIndexWithinBucket(key,bi);
        if(di!=-1){
            Node node = buckets[bi].get(di);
            return node.value;
        }
        return -1;
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    public void remove(int key) {
        int bi = hashFn(key);
        int di = getIndexWithinBucket(key,bi);
        if(di!=-1){
            Node node = buckets[bi].remove(di);
            size--;
            // return node.value;
        }
        // return -1;
    }
}
